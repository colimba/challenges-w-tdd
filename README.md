# Acerca de tdd-training

Pr√°cticas con TDD haciendo retos propuestos por [adventjs](https://adventjs.dev/).

Dependencia para ejecuci√≥n de test üëâ [vitest](https://vitest.dev/) `npm run test` üöÄ 

## 1. [Contando ovejas para dormir](https://adventjs.dev/challenges/01) (sheepCounter.js)
Considera una lista/array de ovejas. Cada oveja tiene un nombre y un color. Haz una funci√≥n que devuelva una lista con todas las ovejas que sean de color **rojo** y que adem√°s su nombre contenga tanto las letras **n** y **a**, sin importar el orden, las may√∫sculas o espacios.

Por ejemplo, si tenemos las ovejas:
```js
const ovejas = [
  { name: 'Noa', color: 'azul' },
  { name: 'Euge', color: 'rojo' },
  { name: 'Navidad', color: 'rojo' },
  { name: 'Ki Na Ma', color: 'rojo'},
  { name: 'AAAAAaaaaa', color: 'rojo' },
  { name: 'Nnnnnnnn', color: 'rojo'}
]
```
Al ejecutar el m√©todo deber√≠a devolver lo siguiente:
```js
const ovejasFiltradas = contarOvejas(ovejas)
console.log(ovejasFiltradas)
// [{ name: 'Navidad', color: 'rojo' },
//  { name: 'Ki Na Ma', color: 'rojo' }]
```
## 2. [¬°Ayuda al elfo a listar los regalos!](https://adventjs.dev/challenges/02) (listGifts.js)
Te ha llegado una carta ‚úâÔ∏è con todos los regalos que debes preparar. El tema es que es una cadena de texto y es muy dif√≠cil de leer üò±. ¬°Menos mal que han puesto cada regalo separado por espacio! (aunque ten cuidado, porque al ser ni√±os, igual han colado m√°s espacios de la cuenta)

Encima nos hemos dado cuenta que algunas palabras vienen con un `_` delante de la palabra, por ejemplo `_playstation`, que significa que est√° tachado y no se tiene que contar.

Transforma el texto a un objeto que contenga el nombre de cada regalo y las veces que aparece. Por ejemplo, si tenemos el texto:
```js
const carta = 'bici coche bal√≥n _playstation bici coche peluche'
```
Al ejecutar el m√©todo deber√≠a devolver lo siguiente:
```js
const regalos = listGifts(carta)

console.log(regalos)
/*
{
  bici: 2,
  coche: 2,
  bal√≥n: 1,
  peluche: 1
}
*/
```

## 3. [El Grinch quiere fastidiar la Navidad](https://adventjs.dev/challenges/03) (grinchPrank.js)
El Grinch est√° abriendo las cartas que iban a Santa Claus y las est√° dejando hechas un l√≠o. üò±

Las cartas son una cadena de texto que incluyen regalos y par√©ntesis `()`.

Para saber si una carta es v√°lida ‚úÖ, debes comprobar que los par√©ntesis cierran correctamente y que, adem√°s, no vayan vac√≠os.

¬°Pero ojo! Porque el Grinch ha dejado llaves `{` y corchetes `[` dentro de los par√©ntesis que hacen que no sean v√°lidas. Por suerte s√≥lo los ha dejado en medio de los par√©ntesis...

Ejemplos:
```js
"bici coche (bal√≥n) bici coche peluche" // -> ‚úÖ
"(mu√±eca) consola bici" // ‚úÖ

"bici coche (bal√≥n bici coche" // -> ‚ùå
"peluche (bici [coche) bici coche bal√≥n" // -> ‚ùå
"(peluche {) bici" // -> ‚ùå
"() bici" // ‚ùå
```
Crea una funci√≥n que pas√°ndole el texto de la carta, devuelva `true` si es v√°lida y `false` si no lo es. ¬°Y acaba con la travesura del Grinch!

## 4. [¬°Es hora de poner la navidad en casa!](https://adventjs.dev/challenges/04) (xmasTree.js)
¬°Es hora de poner el √°rbol de navidad en casa! üéÑ

Para ello vamos a crear una funci√≥n que recibe la altura del √°rbol, que ser√° un entero positivo del 1 a, como m√°ximo, 100.

Si le pasamos el argumento `5`, se pintar√≠a esto:

```
____*____
___***___
__*****__
_*******_
*********
____#____
____#____
```

Creamos un tri√°ngulo de asteriscos `*` con la altura proporcionada y, a los lados, usamos el gui√≥n bajo `_` para los espacios. Es muy importante que nuestro √°rbol siempre tenga la misma longitud por cada lado.

Todos los √°rboles, por peque√±os o grandes que sean, tienen un tronco de dos l√≠neas de `#`.

Otro ejemplo con un √°rbol de altura 3:

```
__*__
_***_
*****
__#__
__#__
```

Ten en cuenta que el √°rbol es un string y necesitas los saltos de l√≠nea `\n` para cada l√≠nea para que se forme bien el √°rbol.

## 5. [Contando los d√≠as para los regalos](https://adventjs.dev/challenges/05) (daysToXmas.js)
Con la emoci√≥n, ya estamos empezando a **contar los d√≠as del calendario hasta el 25 de diciembre üìÜ.**

Para ayudar a esto, vamos a crear una funci√≥n que pas√°ndole una instancia de `Date` nos diga el n√∫mero de d√≠as que faltan.

Veamos unos ejemplos:

```js
const date1 = new Date('Dec 1, 2021')
daysToXmas(date1) // 24
const date2 = new Date('Dec 24, 2021 00:00:01')
daysToXmas(date2) // 1
const date3 = new Date('Dec 24, 2021 23:59:59')
daysToXmas(date3) // 1
const date4 = new Date("December 20, 2021 03:24:00")
daysToXmas(date4) // 5
```

El resultado tiene que ser **un n√∫mero entero** y, como ves, aunque falte un segundo hasta el siguiente d√≠a, se entiende que todav√≠a falta un d√≠a.

**¬°Pero ojo!** Tambi√©n hay que indicar si la fecha es del mismo d√≠a (devolver√≠amos `0`) o si es una fecha futura (devolver√≠amos el n√∫mero de d√≠as en negativo `-`):

```js
const date = new Date('Dec 25, 2021')
daysToXmas(date) // 0
const date1 = new Date('Dec 26, 2021')
daysToXmas(date1) // -1
const date2 = new Date('Dec 31, 2021')
daysToXmas(date2) // -6
const date3 = new Date('Jan 1, 2022 00:00:01')
daysToXmas(date3) // -7
const date4 = new Date('Jan 1, 2022 23:59:59')
daysToXmas(date4) // -7
```

Por cierto, la fecha de referencia para saber si es 25 de diciembre es `Dec 25, 2021`.

## 6. [Rematando los ex√°menes finales](https://adventjs.dev/challenges/06) (sumPairs.js)
Antes de poder disfrutar de la navidad... nos toca terminar de rematar los ex√°menes finales. ¬°Y toca un poco de matem√°ticas! üò±

A una funci√≥n se le pasan dos par√°metros: un Array con n√∫meros y el resultado que se espera.

La funci√≥n debe devolver los dos valores del Array que sumen el resultado esperado. Como a veces pueden haber m√°s de dos valores que sumen, se devolver√° el primero empezando por la izquierda que encuentre otro par, sin importar lo lejos que est√© a la derecha.

Si no se encuentra, se devuelve `null`.

Veamos unos ejemplos:

```js
sumPairs([3, 5, 7, 2], 10) // [3, 7]
sumPairs([-3, -2, 7, -5], 10) // null
sumPairs([2, 2, 3, 1], 4) // [2, 2]
sumPairs([6, 7, 1, 2], 8) // [6, 2]
sumPairs([0, 2, 2, 3, -1, 1, 5], 6) // [1, 5]
```

El resultado tiene que ser **un array con dos n√∫meros.**

Una vez que tengas el resultado... ¬øc√≥mo podr√≠as hacer que fuese lo m√°s √≥ptimo posible para **no tener que recorrer las mismas situaciones dos veces** ü§î?
